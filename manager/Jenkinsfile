// Manager App (Java/Javalin) - Jenkins CI/CD Pipeline
// QA Environment with Comprehensive Testing
// ‚úÖ Unit + API + E2E
// ‚úÖ Allure: per-type results + Combined report in Jenkins
// ‚úÖ JaCoCo: publish coverage (requires JaCoCo plugin OR archives HTML report)
// ‚úÖ Cucumber: publish feature report (requires Cucumber Reports plugin OR archives JSON/HTML)
// ‚úÖ Deploy to QA ONLY when build result is SUCCESS (no UNSTABLE)

pipeline {
  agent any

  environment {
    APP_NAME      = 'expense-manager'
    APP_PORT      = '5001'
    BUILD_VERSION = "${BUILD_NUMBER}"
    APP_URL       = "http://localhost:${APP_PORT}"

    TEST_NETWORK  = "jenkins-test-network"

    CONTAINER_WS  = "/home/appuser/workspace"
    CONTAINER_UID = "1001"
    CONTAINER_GID = "1001"

    SEED_DB_PATH  = "manager/seed/expense_manager.db"
    DB_VOLUME     = "expense-data"

    // ‚úÖ Selenium (single browser container - Chrome only)
    SELENIUM_CONTAINER   = "selenium-chrome"
    SELENIUM_IMAGE       = "selenium/standalone-chrome:4.25.0"
    SELENIUM_REMOTE_URL  = "http://selenium-chrome:4444/wd/hub"

    // ‚úÖ Allure results folders (split per stage to avoid clobbering)
    ALLURE_UNIT = "manager/target/allure-results/unit"
    ALLURE_API  = "manager/target/allure-results/api"
    ALLURE_E2E  = "manager/target/allure-results/e2e"

    // ‚úÖ Generated HTML reports (optional archives; Jenkins UI report is via Allure plugin)
    ALLURE_HTML_ROOT   = "allure-html"
    ALLURE_HTML_UNIT   = "allure-html/unit"
    ALLURE_HTML_API    = "allure-html/api"
    ALLURE_HTML_E2E    = "allure-html/e2e"

    // ‚úÖ Allure CLI (downloaded locally if not present)
    ALLURE_VERSION = "2.27.0"
    ALLURE_HOME    = ".allure/allure-${ALLURE_VERSION}"

    // ‚úÖ Cucumber outputs (host + container)
    CUCUMBER_HOST_DIR   = "manager/target/cucumber"
    CUCUMBER_HOST_JSON  = "manager/target/cucumber/cucumber.json"
    CUCUMBER_CONT_DIR   = "${CONTAINER_WS}/manager/target/cucumber"
    CUCUMBER_CONT_JSON  = "${CONTAINER_WS}/manager/target/cucumber/cucumber.json"

    // ‚úÖ QA deploy container
    QA_CONTAINER   = "${APP_NAME}-qa"
    QA_PORT        = "5001"              // change if you want QA on different port
    QA_DB_VOLUME   = "expense-data-qa"   // separate from test DB
  }

  options {
    buildDiscarder(logRotator(numToKeepStr: '10'))
    timestamps()
    timeout(time: 75, unit: 'MINUTES')
  }

  parameters {
    booleanParam(name: 'SKIP_UNIT_TESTS', defaultValue: false, description: 'Skip Unit Tests stage')
    booleanParam(name: 'SKIP_API_TESTS', defaultValue: false, description: 'Skip API Tests stage')
    booleanParam(name: 'SKIP_E2E_TESTS', defaultValue: false, description: 'Skip E2E Tests stage')
    booleanParam(name: 'SKIP_PERFORMANCE_TESTS', defaultValue: false, description: 'Skip Performance Tests stage')
    booleanParam(name: 'SKIP_CODE_COVERAGE', defaultValue: false, description: 'Skip Code Coverage stage')
    booleanParam(name: 'SKIP_ALLURE', defaultValue: false, description: 'Skip Allure Report stage')
    booleanParam(name: 'SKIP_DEPLOY', defaultValue: false, description: 'Skip Deploy to QA stage')
  }

  stages {

    stage('Checkout') {
      steps {
        echo 'üì• Checking out source code...'
        checkout scm
        script {
          env.GIT_COMMIT_SHORT = sh(script: 'git rev-parse --short HEAD', returnStdout: true).trim()
          echo "Building commit: ${env.GIT_COMMIT_SHORT}"
        }

        sh '''
          set -e
          echo "---- Workspace ----"
          pwd
          ls -la

          echo "---- manager/seed ----"
          ls -la manager/seed || true

          echo "---- Expecting seed DB at: ${SEED_DB_PATH} ----"
          if [ -f "${SEED_DB_PATH}" ]; then
            echo "‚úÖ Seed DB found"
          else
            echo "‚ùå Seed DB NOT found at ${SEED_DB_PATH}"
            exit 1
          fi
        '''
      }
    }

    stage('Build Docker Images') {
      steps {
        echo '‚òï Building Java Manager Docker images...'
        dir('manager') {
          sh '''
            set -e

            docker build \
              -t ${APP_NAME}:${BUILD_VERSION} \
              -t ${APP_NAME}:latest \
              -f Dockerfile .

            docker build \
              --target testrunner \
              -t ${APP_NAME}-testrunner:${BUILD_VERSION} \
              -f Dockerfile .
          '''
        }
      }
    }

    stage('Unit Tests') {
      when { expression { !params.SKIP_UNIT_TESTS } }
      agent {
        docker {
          image 'maven:3.9-eclipse-temurin-21'
          args '-v maven-repo:/root/.m2'
          reuseNode true
        }
      }
      steps {
        echo 'üß™ Running Java Unit Tests...'
        dir('manager') {
          sh '''
            set -e
            rm -rf target/allure-results || true
            rm -rf target/site/jacoco || true
            mvn -B clean test -Dtest="**/unittests/**"
          '''
        }

        // ‚úÖ Copy unit allure results into a dedicated folder
        sh '''
          set -e
          rm -rf "${ALLURE_UNIT}" || true
          mkdir -p "${ALLURE_UNIT}"
          if [ -d "manager/target/allure-results" ]; then
            cp -R manager/target/allure-results/. "${ALLURE_UNIT}/" || true
          fi
          echo "---- Allure UNIT files ----"
          ls -la "${ALLURE_UNIT}" || true
          echo -n "UNIT json count: "; find "${ALLURE_UNIT}" -type f -name "*.json" | wc -l || true
        '''
      }
      post {
        always {
          // NOTE: If any tests failed, this marks build UNSTABLE -> deploy will not run (as requested).
          junit allowEmptyResults: true, testResults: 'manager/target/surefire-reports/*.xml'
        }
      }
    }

    stage('Start Application') {
      when { expression { !params.SKIP_API_TESTS || !params.SKIP_E2E_TESTS } }
      steps {
        echo 'üöÄ Starting Manager App (testrunner image) for Testing...'
        sh '''
          set -e

          docker network create ${TEST_NETWORK} >/dev/null 2>&1 || true

          docker stop ${APP_NAME}-test >/dev/null 2>&1 || true
          docker rm ${APP_NAME}-test >/dev/null 2>&1 || true

          docker volume rm ${DB_VOLUME} >/dev/null 2>&1 || true
          docker volume create ${DB_VOLUME} >/dev/null

          echo "üå± Seeding DB volume with ${SEED_DB_PATH} ..."
          test -f "${SEED_DB_PATH}"

          docker rm -f seed-helper >/dev/null 2>&1 || true
          docker create --name seed-helper -v ${DB_VOLUME}:/data alpine:3.20 >/dev/null
          docker cp "${SEED_DB_PATH}" seed-helper:/data/expense_manager.db
          docker rm -f seed-helper >/dev/null

          docker run --rm -v ${DB_VOLUME}:/data alpine:3.20 sh -lc \
            "chown -R ${CONTAINER_UID}:${CONTAINER_GID} /data && chmod 775 /data && chmod 664 /data/expense_manager.db"

          docker run -d \
            --name ${APP_NAME}-test \
            --network ${TEST_NETWORK} \
            -p ${APP_PORT}:${APP_PORT} \
            -v ${DB_VOLUME}:/data \
            ${APP_NAME}-testrunner:${BUILD_VERSION}

          echo "Waiting for application health (inside container)..."
          for i in $(seq 1 30); do
            if docker exec ${APP_NAME}-test sh -lc "wget -q --spider http://localhost:${APP_PORT}/health"; then
              echo "‚úÖ Application is healthy!"
              sleep 2
              exit 0
            fi
            echo "‚è≥ Not ready yet (${i}/30)..."
            sleep 2
          done

          echo "‚ùå App did not become healthy in time"
          docker logs ${APP_NAME}-test || true
          exit 1
        '''
      }
    }

    stage('Sync Repo Into App Container') {
      when { expression { !params.SKIP_API_TESTS || !params.SKIP_E2E_TESTS } }
      steps {
        echo 'üì¶ Syncing repository into running app container...'
        sh '''
          set -e

          docker exec -u 0 ${APP_NAME}-test sh -lc "
            rm -rf ${CONTAINER_WS} /tmp/repo &&
            mkdir -p ${CONTAINER_WS} /tmp/repo
          "

          docker cp . ${APP_NAME}-test:/tmp/repo

          docker exec -u 0 ${APP_NAME}-test sh -lc "
            rm -rf ${CONTAINER_WS}/* &&
            cp -R /tmp/repo/. ${CONTAINER_WS}/ &&
            chown -R ${CONTAINER_UID}:${CONTAINER_GID} ${CONTAINER_WS} &&
            rm -rf /tmp/repo
          "

          docker exec ${APP_NAME}-test sh -lc "test -f ${CONTAINER_WS}/manager/pom.xml && echo '‚úÖ pom.xml present' || (echo '‚ùå pom.xml missing' && exit 1)"
        '''
      }
    }

    stage('API Tests') {
      when { expression { !params.SKIP_API_TESTS } }
      steps {
        echo "üîå Running Java API Tests INSIDE ${APP_NAME}-test (same container)..."
        sh '''
          set -e

          docker exec ${APP_NAME}-test sh -lc "command -v mvn && mvn -v && java -version"
          docker exec ${APP_NAME}-test sh -lc "test -f /data/expense_manager.db && echo '‚úÖ DB present in /data' || (echo '‚ùå DB missing in /data' && exit 1)"

          # ‚úÖ Clean allure results INSIDE the container for this stage (api)
          docker exec ${APP_NAME}-test sh -lc "
            rm -rf ${CONTAINER_WS}/manager/target/allure-results/api || true
            mkdir -p ${CONTAINER_WS}/manager/target/allure-results/api
          "

          docker exec ${APP_NAME}-test sh -lc '
            set -e
            cd '"${CONTAINER_WS}"'/manager
            rm -rf target || true

            export DATABASE_PATH=/data/expense_manager.db
            export DB_PATH=/data/expense_manager.db

            # ‚úÖ Force Allure results dir for API stage (ABSOLUTE)
            export ALLURE_RESULTS_DIRECTORY="'"${CONTAINER_WS}"'/manager/target/allure-results/api"

            # ‚úÖ IMPORTANT: DO NOT ignore failures (so build becomes UNSTABLE/SUCCESS correctly)
            mvn -B clean test \
              -Dtest="**/integrationtests/**" \
              -Dapp.url=http://localhost:'"${APP_PORT}"' \
              -DbaseUrl=http://localhost:'"${APP_PORT}"' \
              -Dallure.results.directory="'"${CONTAINER_WS}"'/manager/target/allure-results/api"
          '

          # ‚úÖ Copy API allure results OUT of container into Jenkins workspace
          rm -rf "${ALLURE_API}" || true
          mkdir -p "${ALLURE_API}"
          docker cp ${APP_NAME}-test:${CONTAINER_WS}/manager/target/allure-results/api/. "${ALLURE_API}" || true

          echo "---- Allure API files (host) ----"
          ls -la "${ALLURE_API}" || true
          echo -n "API json count (host): "; find "${ALLURE_API}" -type f -name "*.json" | wc -l || true
        '''
      }
      post {
        always {
          // If any tests failed, this marks build UNSTABLE -> deploy will not run (as requested).
          junit allowEmptyResults: true, testResults: '**/target/surefire-reports/*.xml'
        }
      }
    }

    stage('Start Selenium (Chrome)') {
      when { expression { !params.SKIP_E2E_TESTS } }
      steps {
        echo 'üß© Starting Selenium Standalone Chrome...'
        sh '''
          set -e

          docker rm -f "${SELENIUM_CONTAINER}" >/dev/null 2>&1 || true

          docker run -d \
            --name "${SELENIUM_CONTAINER}" \
            --network "${TEST_NETWORK}" \
            -p 4444:4444 \
            -e OTEL_TRACES_EXPORTER=none \
            -e OTEL_METRICS_EXPORTER=none \
            -e OTEL_LOGS_EXPORTER=none \
            "${SELENIUM_IMAGE}"

          echo "Waiting for Selenium (checking /wd/hub/status)..."
          for i in $(seq 1 45); do
            if docker exec "${SELENIUM_CONTAINER}" sh -lc "wget -q --spider http://localhost:4444/wd/hub/status"; then
              echo "‚úÖ Selenium is responding on /wd/hub/status"
              exit 0
            fi
            echo "‚è≥ Not ready yet (${i}/45)..."
            sleep 2
          done

          echo "‚ùå Selenium did not become ready"
          docker logs "${SELENIUM_CONTAINER}" || true
          exit 1
        '''
      }
    }

    stage('E2E Tests (Selenium - Chrome)') {
      when { expression { !params.SKIP_E2E_TESTS } }
      steps {
        echo "üß≠ Running Selenium E2E (Chrome) via RemoteWebDriver..."
        sh '''
          set -e

          # ‚úÖ Confirm selenium reachable from app container
          docker exec ${APP_NAME}-test sh -lc "wget -qO- http://${SELENIUM_CONTAINER}:4444/wd/hub/status | head -c 200"

          # ‚úÖ Clean allure results INSIDE the container for this stage (e2e)
          docker exec ${APP_NAME}-test sh -lc "
            rm -rf ${CONTAINER_WS}/manager/target/allure-results/e2e || true
            mkdir -p ${CONTAINER_WS}/manager/target/allure-results/e2e
          "

          # ‚úÖ Clean cucumber output INSIDE container
          docker exec ${APP_NAME}-test sh -lc "
            rm -rf ${CUCUMBER_CONT_DIR} || true
            mkdir -p ${CUCUMBER_CONT_DIR}
          "

          docker exec ${APP_NAME}-test sh -lc '
            set -e
            cd '"${CONTAINER_WS}"'/manager
            rm -rf target || true

            # IMPORTANT: browser runs in selenium container, so baseUrl must be the APP CONTAINER NAME
            export BASE_URL="http://'${APP_NAME}'-test:'"${APP_PORT}"'"

            # ‚úÖ Force Allure results dir for E2E stage (ABSOLUTE)
            export ALLURE_RESULTS_DIRECTORY="'"${CONTAINER_WS}"'/manager/target/allure-results/e2e"

            # ‚úÖ Try to force cucumber JSON output to a known path
            # This works for many setups; if your project already configures plugins in code/pom,
            # the runner config will still apply. Worst case: you'll still get your existing cucumber output.
            mvn -B clean test \
              -Dtest="com.revature.systemtests.selenium.runners.TestRunner" \
              -DbaseUrl="${BASE_URL}" \
              -Dselenium.remoteUrl="'${SELENIUM_REMOTE_URL}'" \
              -Dbrowser=chrome \
              -Dallure.results.directory="'"${CONTAINER_WS}"'/manager/target/allure-results/e2e" \
              -Dcucumber.plugin="pretty, json:'"${CUCUMBER_CONT_JSON}"'"
          '

          # ‚úÖ Copy E2E allure results OUT of container into Jenkins workspace
          rm -rf "${ALLURE_E2E}" || true
          mkdir -p "${ALLURE_E2E}"
          docker cp ${APP_NAME}-test:${CONTAINER_WS}/manager/target/allure-results/e2e/. "${ALLURE_E2E}" || true

          echo "---- Allure E2E files (host) ----"
          ls -la "${ALLURE_E2E}" || true
          echo -n "E2E json count (host): "; find "${ALLURE_E2E}" -type f -name "*.json" | wc -l || true

          # ‚úÖ Copy Cucumber outputs OUT of container into Jenkins workspace
          rm -rf "${CUCUMBER_HOST_DIR}" || true
          mkdir -p "${CUCUMBER_HOST_DIR}"
          docker cp ${APP_NAME}-test:${CUCUMBER_CONT_DIR}/. "${CUCUMBER_HOST_DIR}" >/dev/null 2>&1 || true

          echo "---- Cucumber outputs (host) ----"
          ls -la "${CUCUMBER_HOST_DIR}" || true
          if [ -f "${CUCUMBER_HOST_JSON}" ]; then
            echo "‚úÖ Found cucumber.json at ${CUCUMBER_HOST_JSON}"
          else
            echo "‚ö†Ô∏è cucumber.json not found at ${CUCUMBER_HOST_JSON} (your runner may be writing elsewhere)"
            echo "Searching for cucumber json under manager/target..."
            find manager/target -maxdepth 4 -type f -name "*cucumber*.json" -print || true
          fi
        '''
      }
      post {
        always {
          junit allowEmptyResults: true, testResults: 'manager/target/surefire-reports/*.xml'
        }
      }
    }

    stage('Stop Selenium (Chrome)') {
      when { expression { !params.SKIP_E2E_TESTS } }
      steps {
        echo 'üßπ Stopping Selenium Chrome container...'
        sh '''
          docker rm -f "${SELENIUM_CONTAINER}" >/dev/null 2>&1 || true
        '''
      }
    }

    stage('Stop Test Container') {
      steps {
        echo 'üõë Stopping test container...'
        sh '''
          docker stop ${APP_NAME}-test || true
          docker rm ${APP_NAME}-test || true
        '''
      }
    }

    // -----------------------------
    // Reports (Allure + JaCoCo + Cucumber)
    // -----------------------------
    stage('Publish Reports (Allure + JaCoCo + Cucumber)') {
      when { expression { !params.SKIP_ALLURE } }
      steps {
        echo 'üìä Publishing reports...'
        sh '''
          set -e

          echo "---- Pre-Publish Sanity Check (host) ----"
          echo "UNIT:"; ls -la manager/target/allure-results/unit || true
          echo "API:";  ls -la manager/target/allure-results/api  || true
          echo "E2E:";  ls -la manager/target/allure-results/e2e  || true

          echo "json counts:"
          echo -n "UNIT: "; find manager/target/allure-results/unit -type f -name "*.json" | wc -l || true
          echo -n "API:  "; find manager/target/allure-results/api  -type f -name "*.json" | wc -l || true
          echo -n "E2E:  "; find manager/target/allure-results/e2e  -type f -name "*.json" | wc -l || true

          echo "---- Cucumber (host) ----"
          ls -la "${CUCUMBER_HOST_DIR}" || true
        '''
      }
      post {
        always {
          // ‚úÖ 1) Publish ONE combined Allure report in Jenkins UI
          allure([
            includeProperties: false,
            results: [
              [path: 'manager/target/allure-results/unit'],
              [path: 'manager/target/allure-results/api'],
              [path: 'manager/target/allure-results/e2e']
            ]
          ])

          // ‚úÖ 2) Archive Cucumber outputs so you always have them, even if plugin isn't installed
          archiveArtifacts artifacts: 'manager/target/cucumber/**', allowEmptyArchive: true

          // ‚úÖ 3) Publish Cucumber report in Jenkins if the Cucumber Reports plugin is installed
          // (If the plugin is missing, this won't break the pipeline.)
          script {
            try {
              // Most Jenkins Cucumber plugins look for JSON files under the workspace
              cucumber buildStatus: 'UNSTABLE', fileIncludePattern: '**/target/cucumber/*.json'
            } catch (Exception e) {
              echo "‚ÑπÔ∏è Cucumber publisher not available or failed: ${e.getMessage()}"
            }
          }

          // ‚úÖ 4) JaCoCo: generate HTML report (if plugin configured in pom) + archive it
          // If your pom already generates JaCoCo automatically, this folder will exist after tests:
          // manager/target/site/jacoco
          archiveArtifacts artifacts: 'manager/target/site/jacoco/**', allowEmptyArchive: true

          // ‚úÖ 5) Publish JaCoCo in Jenkins if JaCoCo plugin is installed and jacoco.exec exists
          script {
            try {
              jacoco(
                execPattern: 'manager/target/*.exec, manager/target/jacoco.exec',
                classPattern: 'manager/target/classes',
                sourcePattern: 'manager/src/main/java',
                changeBuildStatus: true
              )
            } catch (Exception e) {
              echo "‚ÑπÔ∏è JaCoCo publisher not available or failed: ${e.getMessage()}"
            }
          }
        }
      }
    }

    // -----------------------------
    // Deploy to QA (Docker) - ONLY on SUCCESS (your requirement)
    // -----------------------------
    stage('Deploy to QA') {
      when {
        allOf {
          expression { !params.SKIP_DEPLOY }
          branch 'main'
          expression { currentBuild.currentResult == null || currentBuild.currentResult == 'SUCCESS' }
        }
      }
      steps {
        echo "üöÄ Deploying ${APP_NAME}:${BUILD_VERSION} to QA (container: ${QA_CONTAINER})..."
        sh '''
          set -e

          docker volume create "${QA_DB_VOLUME}" >/dev/null

          docker stop "${QA_CONTAINER}" >/dev/null 2>&1 || true
          docker rm   "${QA_CONTAINER}" >/dev/null 2>&1 || true

          docker network create "${TEST_NETWORK}" >/dev/null 2>&1 || true

          docker run -d \
            --name "${QA_CONTAINER}" \
            --restart unless-stopped \
            --network "${TEST_NETWORK}" \
            -p "${QA_PORT}:${APP_PORT}" \
            -v "${QA_DB_VOLUME}:/data" \
            ${APP_NAME}:${BUILD_VERSION}

          echo "Waiting for QA health..."
          for i in $(seq 1 40); do
            if docker exec "${QA_CONTAINER}" sh -lc "wget -q --spider http://localhost:${APP_PORT}/health"; then
              echo "‚úÖ QA deployment healthy!"
              exit 0
            fi
            echo "‚è≥ Not ready yet (${i}/40)..."
            sleep 2
          done

          echo "‚ùå QA did not become healthy"
          docker logs "${QA_CONTAINER}" || true
          exit 1
        '''
      }
    }
  }

  post {
    always {
      echo 'üßπ Cleaning up test infra...'
      sh '''
        docker stop ${APP_NAME}-test >/dev/null 2>&1 || true
        docker rm   ${APP_NAME}-test >/dev/null 2>&1 || true

        docker rm -f "${SELENIUM_CONTAINER}" >/dev/null 2>&1 || true

        docker rmi ${APP_NAME}-testrunner:${BUILD_VERSION} >/dev/null 2>&1 || true
        # Keep ${APP_NAME}:${BUILD_VERSION} so QA container can run it (do not delete here)
      '''
    }
    failure {
      echo '‚ùå Pipeline failed! Check console output for details.'
    }
  }
}
