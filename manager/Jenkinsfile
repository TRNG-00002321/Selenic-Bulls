// Manager App (Java/Javalin) - Jenkins CI/CD Pipeline
// Option B: Run API tests INSIDE the SAME running app container (no separate test docker container)

pipeline {
  agent any

  environment {
    APP_NAME      = 'expense-manager'
    APP_PORT      = '5001'
    BUILD_VERSION = "${BUILD_NUMBER}"

    // Used for host-based checks; inside the app container we'll use localhost:${APP_PORT}
    APP_URL = "http://localhost:${APP_PORT}"
  }

  options {
    buildDiscarder(logRotator(numToKeepStr: '10'))
    timestamps()
    timeout(time: 45, unit: 'MINUTES')
  }

  parameters {
    booleanParam(name: 'SKIP_UNIT_TESTS', defaultValue: false, description: 'Skip Unit Tests stage')
    booleanParam(name: 'SKIP_API_TESTS', defaultValue: false, description: 'Skip API Tests stage')
    booleanParam(name: 'SKIP_E2E_TESTS', defaultValue: false, description: 'Skip E2E Tests stage')
    booleanParam(name: 'SKIP_PERFORMANCE_TESTS', defaultValue: false, description: 'Skip Performance Tests stage')
    booleanParam(name: 'SKIP_CODE_COVERAGE', defaultValue: false, description: 'Skip Code Coverage stage')
    booleanParam(name: 'SKIP_ALLURE', defaultValue: false, description: 'Skip Allure Report stage')
    booleanParam(name: 'SKIP_DEPLOY', defaultValue: false, description: 'Skip Deploy to QA stage')
  }

  stages {

    stage('Checkout') {
      steps {
        echo 'üì• Checking out source code...'
        checkout scm
        script {
          env.GIT_COMMIT_SHORT = sh(script: 'git rev-parse --short HEAD', returnStdout: true).trim()
          echo "Building commit: ${env.GIT_COMMIT_SHORT}"
        }
      }
    }

    // ============================================
    // FAIL FAST: unit tests before container build
    // ============================================
    stage('Unit Tests') {
      when { expression { !params.SKIP_UNIT_TESTS } }
      agent {
        docker {
          image 'maven:3.9-eclipse-temurin-21'
          args '-v maven-repo:/root/.m2'
          reuseNode true
        }
      }
      steps {
        echo 'üß™ Running Java Unit Tests...'
        dir('manager') {
          sh 'mvn -B clean test -Dtest="**/unittests/**"'
        }
      }
      post {
        always {
          junit allowEmptyResults: true, testResults: 'manager/target/surefire-reports/*.xml'
        }
      }
    }

    // ============================================
    // BUILD IMAGE (before API/E2E that hit app)
    // ============================================
    stage('Build Docker Image') {
      steps {
        echo '‚òï Building Java Manager Docker image...'
        dir('manager') {
          sh '''
            docker build \
              -t ${APP_NAME}:${BUILD_VERSION} \
              -t ${APP_NAME}:latest \
              -f Dockerfile .
          '''
        }
      }
    }

    // ============================================
    // START APP (and mount workspace into it)
    // ============================================
    stage('Start Application') {
      steps {
        echo 'üöÄ Starting Manager App for API/E2E Testing...'
        sh '''
          set -e

          # Create custom network for test containers (still fine even if you don't use separate test containers)
          docker network create jenkins-test-network || true

          # Clean up old containers
          docker stop ${APP_NAME}-test || true
          docker rm ${APP_NAME}-test || true

          # Remove old volume to ensure clean state
          docker volume rm expense-data || true
          docker volume create expense-data

          # Start app on custom network and mount workspace (so we can run mvn inside the same container)
          docker run -d \
            --name ${APP_NAME}-test \
            --network jenkins-test-network \
            -p ${APP_PORT}:${APP_PORT} \
            -v expense-data:/data \
            -v "${WORKSPACE}/manager:/workspace/manager" \
            ${APP_NAME}:${BUILD_VERSION}

          echo "Waiting for application health (inside container)..."
          for i in $(seq 1 30); do
            if docker exec ${APP_NAME}-test sh -lc "wget -q --spider http://localhost:${APP_PORT}/health"; then
              echo "‚úÖ Application is healthy!"
              sleep 3
              exit 0
            fi
            echo "‚è≥ Not ready yet (${i}/30)..."
            sleep 2
          done

          echo "‚ùå App did not become healthy in time"
          docker logs ${APP_NAME}-test || true
          exit 1
        '''
      }
    }

    // ==========================================================
    // API TESTS (Option B): Run INSIDE the SAME running app container
    // ==========================================================
    stage('API Tests') {
      when { expression { !params.SKIP_API_TESTS } }
      steps {
        echo "üîå Running Java API Tests INSIDE ${APP_NAME}-test (same container)..."
        sh '''
          set -e

          # IMPORTANT:
          # This assumes the running app image has:
          # - a shell (sh)
          # - mvn installed
          # - a JDK available
          #
          # If mvn isn't in the image, this will fail.
          docker exec ${APP_NAME}-test sh -lc '
            cd /workspace/manager && \
            mvn -B test \
              -Dtest="**/integrationtests/**" \
              -Dapp.url=http://localhost:'"${APP_PORT}"' \
              -DbaseUrl=http://localhost:'"${APP_PORT}"' \
              -Dmaven.test.failure.ignore=true
          '
        '''
      }
      post {
        always {
          junit allowEmptyResults: true, testResults: 'manager/target/surefire-reports/*.xml'
        }
      }
    }

    // ============================================
    // E2E TESTS (still run via maven container)
    // NOTE: If you ALSO want E2E in same app container,
    // you can mirror the API Tests approach.
    // ============================================
    stage('E2E Tests') {
      when { expression { !params.SKIP_E2E_TESTS } }
      agent {
        docker {
          image 'maven:3.9-eclipse-temurin-21'
          args '-v maven-repo:/root/.m2 --network jenkins-test-network'
          reuseNode true
        }
      }
      steps {
        echo "üåê Running Java E2E Tests against http://${APP_NAME}-test:${APP_PORT}..."
        dir('manager') {
          sh '''
            mvn -B test \
              -Dtest="**/systemstest/**" \
              -Dapp.url=http://${APP_NAME}-test:${APP_PORT} \
              -DbaseUrl=http://${APP_NAME}-test:${APP_PORT} \
              -Dmaven.test.failure.ignore=true
          '''
        }
      }
      post {
        always {
          junit allowEmptyResults: true, testResults: 'manager/target/surefire-reports/*.xml'
        }
      }
    }

    stage('Code Coverage') {
      when { expression { !params.SKIP_CODE_COVERAGE } }
      agent {
        docker {
          image 'maven:3.9-eclipse-temurin-21'
          args '-v maven-repo:/root/.m2'
          reuseNode true
        }
      }
      steps {
        echo 'üìà Generating JaCoCo Coverage Report...'
        dir('manager') {
          sh 'mvn -B jacoco:report || true'
        }
      }
      post {
        always {
          publishHTML(target: [
            allowMissing: true,
            alwaysLinkToLastBuild: true,
            keepAll: true,
            reportDir: 'manager/target/site/jacoco',
            reportFiles: 'index.html',
            reportName: 'Java Coverage Report'
          ])
        }
      }
    }

    stage('Stop Test Container') {
      steps {
        echo 'üõë Stopping test container...'
        sh '''
          docker stop ${APP_NAME}-test || true
          docker rm ${APP_NAME}-test || true
        '''
      }
    }

    stage('Generate Allure Report') {
      when { expression { !params.SKIP_ALLURE } }
      steps {
        echo 'üìä Generating Allure Report...'
      }
      post {
        always {
          allure([
            includeProperties: false,
            results: [[path: 'manager/target/allure-results']]
          ])
        }
      }
    }

    stage('Deploy to QA') {
      when {
        allOf {
          expression { !params.SKIP_DEPLOY }
          branch 'main'
          expression { currentBuild.currentResult == 'SUCCESS' }
        }
      }
      steps {
        echo 'üöÄ All tests passed! Deploying Manager App to QA...'
        // (keep your existing deploy logic here)
      }
    }
  }

  post {
    always {
      echo 'üßπ Cleaning up...'
      sh '''
        docker stop ${APP_NAME}-test || true
        docker rm ${APP_NAME}-test || true
        docker rmi ${APP_NAME}:${BUILD_VERSION} || true
      '''

      archiveArtifacts artifacts: '''
        manager/target/surefire-reports/**/*.xml,
        manager/target/allure-results/**/*,
        manager/target/site/jacoco/**/*
      ''', allowEmptyArchive: true
    }

    failure {
      echo '‚ùå Pipeline failed! Check console output for details.'
    }
  }
}
